---
title: 3.31携程后端（凉）面经
date: 2022-03-31 22:52:37
tags: [面经]
categories: [自言自语]
cover:
summary: 3.31携程后端（凉）面经
img: /medias/featureimages/34.jpg
---

第一次找工作面试，凉透。。。意料之中

3.23通知笔试，3.24笔试，四道算法题，a了两题多

3.30通知面试，预约面试时间只剩3.31了😭，因为学校作业多，所以只准备了一天，背了一堆八股文，结果一点没用上。。。

面试官进来先看了我简历，估计发现我做的项目和投递的岗位没啥关系，直接说我这里面试是两道编程题。。。

##### 1. HashMap

先问我对HashMap有没有了解，我说这个看过，然后说了一点底层实现原理，包括如何解决哈希冲突啥的，也说到了当链表长度超过8时会转成红黑树，面试官好像还挺惊讶，说竟然看过源码，然后就让我实现HashMap，只要get和put方法。一到自己上手就寄，HashMap是大三时学的，当时也自己实现过，但是面试一点没想起来，最后写了个贼拉垮的代码，没解决哈希冲突。。。孔子曰：学而时习之。太有道理了！！！

下面是我面试结束后复习了一下课件，重新写了一遍的代码

```java
public class MyHashMap {
    private final int MAX_LEN = 1000;
    private List<Pair<Integer, String>>[] arr = new ArrayList[MAX_LEN];

    public MyHashMap() {
        for (int i = 0;i < arr.length;i++) {
            arr[i] = new ArrayList();
        }
    }
    public void put(int key, String value) {
        int k = calHash(key);
        int pos = getPos(key, value);
        if (pos == -1) {
            arr[k].add(new Pair<>(key, value));
        }else {
            arr[k].set(pos, new Pair<>(key, value));
        }
    }

    public String get(int key) {
        int k = calHash(key);
        if (arr[k].size() == 0) {
            return null;
        }else {
            for (int i = 0; i < arr[k].size(); ++i) {
                if (key == arr[k].get(i).getKey()) {
                    return arr[k].get(i).getValue();
                }
            }
        }
        return null;
    }
    public int getPos(int key, String value) {
        int k = calHash(key);
        if (arr[k].size() == 0) {
            return -1;
        }else {
            for (int i = 0; i < arr[k].size(); ++i) {
                if (arr[k].get(i).getKey() == key) {
                    return i;
                }
            }
        }
        return -1;
    }
    public int calHash(int key) {
        return key % MAX_LEN;
    }
}
```

##### 2. 多线程

先问我有没有了解过java中线程池怎么使用，显然没有，根本就没做过java的项目。。。

然后就问了怎么用多线程实现打印一个数组，在打印完成后输出打印完成。。。显然我也不会，直接和面试官说了。。。又问我gc知不知道，也是不会🤦‍♂️面试官直接说感觉准备不充分（gg）

面试后看了好久多线程，写了以下代码，不知道对错

```java
public class Main {

    static volatile int i = 0;

    public static void main(String[] args) {
        int[] arr = new int[100];
        final CountDownLatch latch = new CountDownLatch(2);
        for (int i = 0; i < arr.length; ++i) {
            arr[i] = i;
        }

        new Thread() {
            @Override
            public void run() {
                System.out.println("Thread1");
                synchronized (this) {
                    while (i < 100) {
                        System.out.println(arr[i++]);
                    }
                }
                latch.countDown();
            }
        }.start();

        new Thread() {
            @Override
            public void run() {
                System.out.println("Thread2");
                synchronized (this) {
                    while (i < 100) {
                        System.out.println(arr[i++]);
                    }
                }
                latch.countDown();
            }
        }.start();

        try {
            latch.await();
        }catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("打印结束");
    }
}
```

##### 3. 经典TopK问题

总感觉Leetcode上看见过，但就是没刷过。。。

问了以后直接懵了，没思路（还是题刷的不够多）。。。面试官一直提醒我说用堆，我以为把数组建堆，每次取根节点，再调整堆。。。然后他问了下算法复杂度，我说是$O(n\log (n))$，确实算法复杂度和快排没区别。。面试结束后查了才知道，先将数组前k个值建堆，再是后面的元素依次和堆顶元素比较，这样算法复杂度是$O(n\log(k))$。。。过段时间去做下这个题，再附上代码

4月3日更新，今天做了一下TopK问题，有思路以后其实不难，代码核心还是调整堆的代码

```java
public class TopK{
  	//牛客上这道题的输入输出
  	public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> ans = new ArrayList<>();
        if (k == 0) {
            return ans;
        }
        if (k >= input.length) {
            for (int i = 0; i < input.length; ++i) {
                ans.add(input[i]);
            }
            return ans;
        }
        int[] ks = new int[k];
        for (int i = 0; i < k; i++) {
            ks[i] = input[i];
        }
        for (int i = (k-1)/2; i >= 0; i--) {
            adjustHeap(ks, i, k);
        }
        for (int i = k; i < input.length; i++) {
            if (input[i] < ks[0]) {
                ks[0] = input[i];
                adjustHeap(ks, 0, k);
            }
        }
        for (int i = 0; i < k; ++i) {
            ans.add(ks[i]);
        }
        return ans;
    }
  	
  	//核心代码，和堆排一样，根据问题去建立最大堆或者最小堆
  	//这里是建立最大堆，因为要取前k个最小值，每次把堆顶即最大值和数组接下来的值比较，比堆顶元素小的值就和堆顶元素交换
  	public void adjustHeap(int[] nums, int parent, int length) {
        int temp = nums[parent];
        int leftnode = 2*parent + 1;
        while (leftnode < length) {
            int rightnode = leftnode + 1;
            if (rightnode < length && nums[rightnode] > nums[leftnode]) {
                leftnode++;
            }
            if (temp >= nums[leftnode]) {
                break;
            }
            nums[parent] = nums[leftnode];
            parent = leftnode;
            leftnode = 2*parent + 1;
        }
        nums[parent] = temp;
    }
}
```

##### 4. 总结

就是透心凉，被虐杀的感觉。。还是太菜，后端知识点确实也多，还有一堆没预习过hhh

不管怎么说，也算是积累了一定的经验，也是很有意义的一次面试，毕竟第一次找工面试就直接编程题。。。

最后我和面试官解释了一下，说我投错岗位了，投成春招全职了。。。我说我9月份还要去HKU读研究生，面试官也是恭喜我🤦‍♂️。

最后我问了一下什么时候出结果，他说大概一周后，我说估计是没了，他就笑笑。。。那就是真的没了



最后的最后：不积跬步，无以至千里；不积小流，无以成江海。——《荀子》
