<!DOCTYPE HTML>
<html lang="en">


<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta name="keywords" content="Formal Languages, 学习, 算法, java, 记录">
    <meta name="description" content="大学狗的学习之旅">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Formal Languages | 再`見</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>


<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/timg.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">再`見</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/timg.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">再`見</div>
        <div class="logo-desc">
            
            大学狗的学习之旅
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/scycy2/scycy2.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #fff467;
        fill: #ffcccc;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/scycy2/scycy2.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Formal Languages</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Language-and-Computation/">
                                <span class="chip bg-color">Language and Computation</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/class-notes/" class="post-category">
                                class notes
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-05-15
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2021-09-17
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    6.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    41 Min
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h4 id="1-Basic-Concepts"><a href="#1-Basic-Concepts" class="headerlink" title="1. Basic Concepts"></a>1. Basic Concepts</h4><ul>
<li><p><strong>Alphabet</strong>: a finite, nonempty set $\Sigma$ of symbols.</p>
</li>
<li><p><strong>String</strong>: a finite sequence of symbols from $\Sigma$</p>
</li>
<li><p>substring, prefix and suffix</p>
</li>
<li><p>The empty string has length 0 and is written as $\lambda$</p>
<ul>
<li>It is a prefix, substring and suffix of any given string</li>
<li>Operations (suppose <strong>v = aba</strong> and <strong>w = abaaa</strong>):<ul>
<li>Concatenation: <strong>vw = abaabaaa</strong></li>
<li>Reverse: <strong>w<sup>R</sup> = aaaba</strong></li>
<li>Repetition: <strong>v<sup>2</sup> = abaaba</strong> and <strong>v<sup>0</sup> = $\lambda$</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>If $\Sigma$ is an alphabet, then we use $\Sigma^{<em>}$ to denote the set of strings obtained by concatenating zero or more symbols from $\Sigma$. The set $\Sigma^{</em>}$ always contains $\lambda$.</p>
<ul>
<li>$\Sigma^{*}$ = the set of <strong>all strings</strong> formed by concatenating zero or more symbols in $\Sigma$</li>
<li>$\Sigma^{+}$ = the set of all <strong>non-empty</strong> strings formed by concatenating symbols in $\Sigma$</li>
<li>$\Sigma^{+} = \Sigma^{*} - {\lambda}$</li>
</ul>
</li>
<li><p>A <strong>formal language L</strong> is any subset of $\Sigma^{*}$</p>
<ul>
<li>The <strong>complement</strong> of <strong>L</strong> is: $\overline{L} = \Sigma^{*} - L$</li>
<li>Reverse: $L^{R} = {w^{R}, w\in L}$</li>
<li>Concatenation: $L_{1}L_{2} = {xy: x\in L_{1}, y \in L_{2}}$</li>
<li>$L^{n}$ as $L$ concatenated with itself $n$ times<ul>
<li>$L^{0} = {\lambda}$</li>
<li>$L^{1} = L$</li>
</ul>
</li>
<li><strong>Star-closure</strong>: $L^{*} = L^{0}\bigcup L^{1}\bigcup L^{2}\cdots$</li>
<li><strong>Positive-closure</strong>: $L^{+} = L^{1}\bigcup L^2\cdots$</li>
<li>空集和${\lambda}$都是一种语言</li>
</ul>
</li>
<li><p>A grammar G is defined as a quadruple $G = (V, T, S, P)$ (the sets $V$ and $T$ are non-empty and disjoint):</p>
<ul>
<li>$V$: a finite set of objects called <strong>variables</strong> or non-terminal symbols</li>
<li>$T$: a finite set of objects called <strong>terminal symbols</strong></li>
<li>$S\in V$: a special symbol called the <strong>start</strong> symbol</li>
<li>$P$: a finite set of <strong>productions</strong></li>
<li>Production rules are of the form: $x\rightarrow y$, where $x$ is an element of $(V\cup T)^+$ and $y$ is in $(V\cup T)^*$</li>
</ul>
</li>
<li><p>For a given grammar G, the language generated by G, L(G), is the set of all strings derived from the start  symbol.</p>
<ul>
<li>$L(G) = {w\in T^*: S \stackrel*\Rightarrow w}$</li>
<li>If $w\in L(G)$, then the sequence $S\Rightarrow w_1 \Rightarrow w_2 \Rightarrow \cdots \Rightarrow w_n \Rightarrow w$ is a <strong>derivation</strong> of the sentence $w$. The strings $S, w_1, w_2, \cdots, w_n$, which contain variables as well as terminals, are called <strong>sentential forms</strong> of the derivation</li>
</ul>
</li>
<li><p>Automata</p>
<ul>
<li>An automaton is an abstract model of a digital computer</li>
<li>An automaton consists of<ul>
<li>An input mechanism</li>
<li>A control unit</li>
<li>Possibly, a storage mechanism</li>
<li>Possibly, an output mechanism</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Finite-Automata"><a href="#2-Finite-Automata" class="headerlink" title="2. Finite Automata"></a>2. Finite Automata</h4><h5 id="2-1-Deterministic-Finite-Acceptors"><a href="#2-1-Deterministic-Finite-Acceptors" class="headerlink" title="2.1 Deterministic Finite Acceptors"></a>2.1 Deterministic Finite Acceptors</h5><ul>
<li><p>A <strong>deterministic finite acceptor</strong> or <strong>dfa</strong> is defined by the quintuple<br>$$<br>M = (Q, \Sigma, \delta, q_0, F)<br>$$<br>where</p>
<p>​        $Q$ is a finite set of <strong>internal states</strong>,</p>
<p>​        $\Sigma$ is a finite set of symbols called the <strong>input alphabet</strong>,</p>
<p>​        $\delta : Q\times \Sigma \rightarrow Q$ is a total function called the <strong>transition function</strong>,</p>
<p>​        $q_0 \in Q$ is the <strong>initial state</strong>,</p>
<p>​        $F\subseteq Q$ is a set of <strong>finite states</strong>.</p>
</li>
<li><p>Extended Transition Function: $\delta^*$<br>$$<br>\delta^*: Q \times \Sigma^* \rightarrow Q<br>$$<br>For any given $q \in Q, w \in \Sigma^*, a \in \Sigma$:</p>
<p>​    $\delta^*(q,\lambda) = q$</p>
<p>​    $\delta^*(q, wa) = \delta(\delta^*(q, w), a)$</p>
</li>
<li><p>The language accepted by a DFA $M = (Q, \Sigma, \delta, q_0, F)$ is the set of all strings on $\Sigma$ accepted by $M$, i.e. the set of all strings $w$ such that $\delta^*(q_0, w)$ results in a final state:<br>$$<br>L(M) = {w \in \Sigma^* : \delta^*(q_0, w) \in F}<br>$$</p>
</li>
<li><p><strong>Theorem 2.1</strong></p>
<ul>
<li>Let $M = (Q, \Sigma, \delta, q_0, F)$ be a deterministic finite accepter, and let $G_M$ be its associated transition graph. Then for every $q_i, q_j \in Q$, and $w \in \Sigma^+$, $\delta^*(q_i, w) = q_j$ if and only if there is in $G_M$ a walk with label $w$ from $q_i$ to $q_j$</li>
</ul>
</li>
<li><p>Notes</p>
<ul>
<li>Finite accepters are characterized by having no temporary storage</li>
<li>Since an input file cannot be rewritten, a finite automaton is severely limited in its capacity to “remember” things during the computation</li>
<li>A finite amount of information can be retained in the control unit by placing the unit into a specific state</li>
<li>But since the number of such states is finite, a finite automaton can only deal with situations in which the information to be stored at any time is strictly bounded</li>
</ul>
</li>
<li><p>Regular Languages</p>
<ul>
<li>A language $L$ is <strong>regular</strong> if and only if there is a DFA that accepts $L$</li>
</ul>
</li>
</ul>
<h5 id="2-2-Nondeterministic-Finite-Accepter-NFA"><a href="#2-2-Nondeterministic-Finite-Accepter-NFA" class="headerlink" title="2.2 Nondeterministic Finite Accepter (NFA)"></a>2.2 Nondeterministic Finite Accepter (NFA)</h5><ul>
<li><p>A <strong>nondeterministic finite accepter</strong> or <strong>nfa</strong> is defined by the quintuple<br>$$<br>M = (Q, \Sigma, \delta, q_0, F)<br>$$<br>where $Q, \Sigma, q_0, F$ are defined as for deterministic finite accepter, but<br>$$<br>\delta : Q \times (\Sigma \cup {\lambda}) \rightarrow 2^Q<br>$$<br>where $2^Q$ is the set of all subsets of $Q$ (i.e., the power set of $Q$)</p>
</li>
<li><p>The basic differences between deterministic and nondeterministic finite automata are:</p>
<ul>
<li>In an NFA, a (state, symbol) combination may lead to several states <u>simultaneously</u></li>
<li>An NFA may have <u>undefined transitions</u></li>
<li>If a transition is labeled with the empty string as its input symbol, the NFA may change states <u>without consuming input</u></li>
</ul>
</li>
<li><p>The language $L$ accepted by an nfa $M = (Q, \Sigma, \delta, q_0, F)$ is defined as the set of all strings accepted in the above sense. Formally,<br>$$<br>L(M) = {w \in \Sigma^* : \delta^*(q_0, w) \cap F \neq \emptyset}<br>$$</p>
</li>
</ul>
<h5 id="2-3-Equivalence-of-Deterministic-and-Nondeterministic-Finite-Accepters"><a href="#2-3-Equivalence-of-Deterministic-and-Nondeterministic-Finite-Accepters" class="headerlink" title="2.3 Equivalence of Deterministic and Nondeterministic Finite Accepters"></a>2.3 Equivalence of Deterministic and Nondeterministic Finite Accepters</h5><ul>
<li><strong>Theorem 2.2</strong><ul>
<li>Let $L$ be the language accepted by a nondeterministic finite accepter $M_N = (Q_N, \Sigma, \delta_N, q_0, F_N)$. Then there exists a deterministic finite accepter $M_D = (Q_D, \Sigma, \delta_N, {q_0}, F_D)$ such that $L = L(M_D)$</li>
<li>For <u>any</u> nondeterministic finite accepter, there is an equivalent deterministic finite accepter.</li>
<li>Therefore, <em>every language accepted by a nondeterministic finite accepter is also regular.</em></li>
</ul>
</li>
<li>Procedure: NFA-to-DFA Conversion<ol>
<li>Beginning with the start state, define input transitions for the DFA as follows:<ul>
<li>If the NFA input transition leads to a single state, replicate for the DFA.</li>
<li>If the NFA input transition leads to more than one state, create a new state in the DFA labeled ${q_i, \cdots, q_j}$, where $q_i, \cdots, q_j$ are all the states the NFA transition can lead to.</li>
<li>If the NFA input transition is not defined, the corresponding DFA transition should lead to a trap state.</li>
</ul>
</li>
<li>Repeat step 1 for all newly created DFA states, until no new states are created.</li>
<li>Any DFA state containing an NFA final state in its label should be labeled as final.</li>
<li>If the NFA accepts the empty string, label the start DFA state a final state.</li>
</ol>
</li>
</ul>
<h4 id="3-Regular-Languages-and-Regular-Grammars"><a href="#3-Regular-Languages-and-Regular-Grammars" class="headerlink" title="3. Regular Languages and Regular Grammars"></a>3. Regular Languages and Regular Grammars</h4><h5 id="3-1-Regular-Expressions"><a href="#3-1-Regular-Expressions" class="headerlink" title="3.1 Regular Expressions"></a>3.1 Regular Expressions</h5><ul>
<li><p>Regular Expressions are defined recursively. For any alphabet $\Sigma$:</p>
<ol>
<li>Primitive regular expressions:<ul>
<li>the empty set $\emptyset$</li>
<li>the empty string $\lambda$</li>
<li>any symbol of the alphabet $a \in \Sigma$</li>
</ul>
</li>
<li>If $r_1$ and $r_2$ are regular expressions, then so are:<ul>
<li>the union $r_1 + r_2$</li>
<li>concatenation $r_1 \cdot r_2$ or $r_1r_2$</li>
<li>star closure $r_1^*$</li>
</ul>
</li>
<li>Any string resulting from a <em>finite</em> number of these operations on primitive regular expressions is also a regular expression.</li>
</ol>
</li>
<li><p>Languages Associated with Regular Expressions</p>
<ul>
<li>A regular expressions $r$ denotes a language $L(r)$</li>
<li>Assuming that $r_1$ and $r_2$ are regular expressions:<ol>
<li>The regular expression $\emptyset$ denotes the empty set</li>
<li>The regular expression $\lambda$ denotes the set ${\lambda}$</li>
<li>For any $a$ in the alphabet $\Sigma$, the regular expression $a$ denotes the set ${a}$</li>
<li>The regular expression $r_1 + r_2$ denotes $L(r_1) \cup L(r_2)$</li>
<li>The regular expression $r_1 \cdot r_2$ denotes $L(r_1)L(r_2)$</li>
<li>The regular expression $(r_1)$ denotes $L(r_1)$</li>
<li>The regular expression $r_1^*$ denotes $(L(r_1))^*$</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="3-2-Regular-Expressions-and-Regular-Languages"><a href="#3-2-Regular-Expressions-and-Regular-Languages" class="headerlink" title="3.2 Regular Expressions and Regular Languages"></a>3.2 Regular Expressions and Regular Languages</h5><ul>
<li><p><strong>Theorem 3.1</strong></p>
<ul>
<li>For any regular expression $r$, there is a nondeterministic finite automaton that accepts the language denoted by $r$.</li>
</ul>
</li>
<li><p>Since nondeterministic and deterministic accepters are equivalent, for any regular expression $r$, the language $L(r)$ is also regular.</p>
</li>
<li><p><strong>Primitive regular expressions</strong></p>
<ul>
<li>We can construct simple automata that accept the languages associated with:<ul>
<li>the empty set</li>
<li>the empty string</li>
<li>any individual symbol $a \in \Sigma$</li>
</ul>
</li>
</ul>
<img src="/2021/05/15/Formal-Languages/Screen Shot 2021-03-23 at 11.56.19 AM.png" style="zoom:50%;">

<ul>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-03-23 at 12.03.27 PM.png" style="zoom:50%;"></li>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-03-23 at 12.04.22 PM.png" style="zoom:50%;"></li>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-03-23 at 12.04.52 PM.png" style="zoom:50%;"></li>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-03-23 at 12.05.25 PM.png" style="zoom:50%;"></li>
</ul>
</li>
<li><p>Regular Expressions for Regular Languages</p>
<ul>
<li><strong>Theorem 3.2</strong><ul>
<li>For every regular language $L$, it is possible to construct a corresponding regular expression $r$ satisfying $L = L(r)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-3-Regular-grammars"><a href="#3-3-Regular-grammars" class="headerlink" title="3.3 Regular grammars"></a>3.3 Regular grammars</h5><ul>
<li><p>A grammar $G = (V, T, S, P)$ is said to be <strong>right-linear</strong> if all productions are of the form<br>$$<br>A \rightarrow xB,\<br>A \rightarrow x,<br>$$<br>where $A, B \in V$, and $x \in T^*$. A grammar is said to be <strong>left-linear</strong> if all productions are of the form<br>$$<br>A \rightarrow Bx,\<br>A \rightarrow x.<br>$$</p>
</li>
<li><p>In a <em><u>right-linear grammar</u></em>, at most one variable symbol appears on the right side of any production. If it occurs, it is the <em><strong>rightmost</strong></em> symbol.</p>
</li>
<li><p>In a <em><u>left-linear grammar</u></em>, at most one variable symbol appears on the right side of any production. If it occurs, it is the <em><strong>leftmost</strong></em> symbol.</p>
</li>
<li><p>A <strong>regular grammar</strong> is one that is either right-linear or left-linear.</p>
</li>
<li><p>Right-Linear grammars Generate Regular Languages</p>
<ul>
<li><strong>Theorem 3.3</strong><ul>
<li>For any given right-linear grammar $G$, the language $L(G)$ is regular</li>
</ul>
</li>
<li>The algorithm for constructing an NFA to accept the language generated by a given right-linear grammar $G$:<ul>
<li>Label the NFA start state with $S$ and a final state $V_f$</li>
<li>For every variable symbol $V_i$ in $G$, create an NFA state and label it $V_i$</li>
<li>For each production of the form $A \rightarrow aB$, label a transition from state $A$ to $B$ with symbol $a$</li>
<li>For each production of the form $A \rightarrow a$, label a transition from state $A$ to $V_f$ with symbol a:<ul>
<li>You need to add intermediate states for productions with more than one terminal on the right hand side.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Right-Linear grammars for Regular Languages</p>
<ul>
<li><strong>Theorem 3.4</strong><ul>
<li>If $L$ is a regular language on the alphabet $\Sigma$, then there exists a right-linear grammar $G = (V, \Sigma, S, P)$ such that $L = L(G)$</li>
</ul>
</li>
<li>There is an algorithm that, given any DFA $M$ accepting a regular language $L$, constructs a right-linear grammar $G$ which generates the same language:<ul>
<li>Each state in the DFA corresponds to a variable symbol in $G$</li>
<li>For each DFA transition from state $A$ to state $B$ labeled with symbol $a$, there is a production of the form $A \rightarrow aB$ in $G$</li>
<li>For each final state $F_i $ in the DFA, there is a corresponding production $F_i \rightarrow \lambda$ in $G$</li>
</ul>
</li>
</ul>
</li>
<li><p>Equivalence of Regular Languages and Regular grammars</p>
<ul>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-03-27 at 12.46.52 PM.png" style="zoom:50%;"></li>
</ul>
</li>
</ul>
<h4 id="4-Properties-of-Regular-Languages"><a href="#4-Properties-of-Regular-Languages" class="headerlink" title="4. Properties of Regular Languages"></a>4. Properties of Regular Languages</h4><ul>
<li><p>Closure Properties</p>
<ul>
<li><strong>Theorem 4.1</strong><ul>
<li>If $L_1$ and $L_2$ are regular languages, so are the languages that result from the following operations:<ul>
<li>$L_1 \cup L_2$</li>
<li>$L_1 \cap L_2$</li>
<li>$L_1L_2$</li>
<li>$\overline{L_1}$</li>
<li>$L_1^*$</li>
</ul>
</li>
<li>In other words, the family of regular language is <strong>closed</strong> under union, intersection, concatenation, complementation, and star-closure.</li>
</ul>
</li>
</ul>
</li>
<li><p>Closure under Reversal</p>
<ul>
<li><strong>Theorem 4.2</strong><ul>
<li>If $L$ is a regular language, so is $L^R$</li>
</ul>
</li>
</ul>
</li>
<li><p>A Membership Algorithm for Regular Languages</p>
<ul>
<li>We say that a regular language is given in a <strong>standard representation</strong> if and only if it is described by one of the following:<ul>
<li>a finite automaton,</li>
<li>a regular expression,</li>
<li>or a regular grammar</li>
</ul>
</li>
<li><strong>Theorem 4.5</strong> confirms the existence of a <strong>membership</strong> algorithm for reguklar languages</li>
<li>To determine if an arbitrary string $w$ is in a regular language $L$, we assume we are given a standard representation of $L$m which we then convert to a DFA that accepts $L$</li>
<li>Simulate the operation of the DFA while processing $w$ as the input string</li>
<li>If the machine halts in a final state after processing $w$, then $w\in L$, otherwise, $w\notin L$.</li>
</ul>
</li>
<li><p>Determining whether a regular language is empty, finite or infinite</p>
<ul>
<li><strong>Theorem 4.6</strong> confirms the existence of an <em><strong>algorithm</strong></em> to determine if a regular language is <em><strong>empty, finite, or infinite</strong></em></li>
<li>Given the <em><strong>transition graph</strong></em> of a DFA that accepts $L$,<ul>
<li>If there is a simple path from the start state to any final state, $L$ is not empty (since it contains, at least, the corresponding string)</li>
<li>If a path form the start state to a final state includes a vertex which is the base of some cycle, $L$ is infinite (otherwise, $L$ is finite)</li>
</ul>
</li>
</ul>
</li>
<li><p>Determining whether two regular languages are equal</p>
<ul>
<li><p><strong>Theorem 4.7</strong> confirms the existence of an algorithm to determine if two regular languages $L_1$ and $L_2$ are equal:</p>
<ul>
<li><p>Define the language $L = (L_1 \cap \overline{L_2}) \cup (\overline{L_1} \cap L_2)$</p>
</li>
<li><p>By closure properties, $L$ is regular</p>
</li>
<li><p>So we can construct a DFA $M$ to accept it, and by Theorem 4.6, we can determine whether $L$ is emoty or not.</p>
</li>
<li><p>$L_1$ and $L_2$ are equal if and only if $L$ is empty</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Identifying Non-regular Languages</p>
<ul>
<li><p><strong>Pigeonhole Principle:</strong> If we put $n$ objects into $m$ boxes (pigeonholes), and if $n &gt; m$, then at least one box must have more than one item in it.</p>
</li>
<li><p>This simple principle is the basis of most of the methods for proving non-regularity of languages.</p>
</li>
<li><p><strong>Basic observation:</strong> Although regular languages can be <em>infinite</em>, their associated automata have <em>finite</em> memory.</p>
</li>
</ul>
</li>
<li><p>The Pumping Lemma</p>
<ul>
<li>Suppose that $M = (Q, \Sigma, \delta, q_0, F)$ is a DFA with $n$ states that accepts a language $L$:<ul>
<li>If it accepts a string $x$ such that $|x| \ge n$, then by the time $n$ symbols have been read, $M$ must have entered some state more than once;</li>
<li>In other words, there must be two different prefixes $u$ and $uv$ such that $\delta^*(q_0, u) = \delta^*(q_0, uv)$</li>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-05-03 at 4.16.49 PM.png" style="zoom:50%;"></li>
</ul>
</li>
<li>This implies that there are many more strings in $L$, because we can traverse the loop $v$ any number of times (including leaving it out altogether).</li>
<li>In other words, all of the string $uv^iw$ for $i \ge 0$ are in $L$</li>
<li>This fact is known as the <em><strong>Pumping Lemma for Regular Languages</strong></em>.</li>
<li><strong>Theorem (<em>pumping property</em>):</strong> Suppose that $L$ is a language over $\Sigma$. If $L$ is accepted by the DFA $M = (Q, \Sigma, \delta, q_0, F)$, then there is an integer $n$ so that for every $x$ in $L$ satisfying $|x| \ge n$, there are three strings $u, v$, and $w$ such that $x = uvw$ and:<ul>
<li>$|uv| \le n$;</li>
<li>$v &gt; 0 (i.e. v \ne \lambda) $</li>
<li>For every $i \ge 0$, the string $uv^iw$ belongs to $L$</li>
</ul>
</li>
<li>The way we found $n$ was to take the number of states in an FA accepting $L$.</li>
<li>In many applications we don’t need to know this, only that there is such an $n$.</li>
<li>The statement of the Pumping lemma is as follows:<ul>
<li>If $L$ is regular $\Rightarrow$ the pumping property holds</li>
</ul>
</li>
<li>In practice, we use the contrapositive:<ul>
<li>If the pumping property does not hold $\Rightarrow$ the language $L$ is not regular</li>
</ul>
</li>
<li>Thus, the most common application of the pumping lemma is to show that a language is not regular</li>
<li>The proof is by contradiction. We suppose that the language can be accepted by an FA, and we let $n$ be the integer in the pumping lemma</li>
<li>Then we choose a string $x$ with $|x| \ge n$ to which we can apply the lemma so as to get a contradiction.</li>
<li>Note that the Pumping lemma only provides a <em><strong>necessary</strong></em> condition, but not a sufficient one.<ul>
<li>If $L$ is regular $\Rightarrow$ the pumping property holds</li>
</ul>
</li>
<li>In other words, it does not say anything about the pumping property when L is not regular</li>
<li>In fact, <em><strong>there are languages that do satisfy the pumping lemma, but are not regular</strong></em>, e.g.:<ul>
<li>$L = {a^ib^jc^j\mid i\ge 1\ and\ j \ge 0}\cup{b^jc^k\mid j\ge 0\ and\ k\ge 0}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-Context-Free-Languages"><a href="#5-Context-Free-Languages" class="headerlink" title="5. Context Free Languages"></a>5. Context Free Languages</h4><h5 id="5-1-Context-Free-Grammars"><a href="#5-1-Context-Free-Grammars" class="headerlink" title="5.1 Context-Free Grammars"></a>5.1 Context-Free Grammars</h5><ul>
<li><p>Definition:</p>
<ul>
<li><p>We call $G = (V, \Sigma, S, P)$ a <strong><em>context-free grammar</em> (CFG)</strong> if all productions in $P$ have the form:</p>
<ul>
<li>$A\rightarrow x$</li>
</ul>
<p>in which $A\in V$, and $x\in (V\cup\Sigma)^*$.</p>
</li>
<li><p>We say that $L$ is a <strong><em>context-free language</em> (CFG)</strong> if and only if there is a context-free grammar $G$ such that $L = L(G)$</p>
<ul>
<li>In other words, a language is context-free if it is generated by a context-free grammar.</li>
</ul>
</li>
</ul>
</li>
<li><p>No Restriction on the Right Side</p>
<ul>
<li>A context-free grammar has <em>no restrictions</em> on the right side of its productions.</li>
<li>Therefore, the class of CFLs includes the class of regular languages as a proper subset.</li>
</ul>
</li>
<li><p>Restriction on the Left Side</p>
<ul>
<li>Note that, a context-free grammar does impose a restriction on the <em>left side</em> of productions:<ul>
<li><strong>the left side must be a single variable</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-2-Leftmost-and-Rightmost-Derivations"><a href="#5-2-Leftmost-and-Rightmost-Derivations" class="headerlink" title="5.2 Leftmost and Rightmost Derivations"></a>5.2 Leftmost and Rightmost Derivations</h5><ul>
<li>In a <em>leftmost derivation</em> (LMD), at each step, the leftmost variable in a sentential form is replaced.</li>
<li>In a <em>rightmost derivation</em> (RMD), at each step, the rightmost variable in a sentential form is replaced.</li>
</ul>
<h5 id="5-3-Derivation-Trees"><a href="#5-3-Derivation-Trees" class="headerlink" title="5.3 Derivation Trees"></a>5.3 Derivation Trees</h5><ul>
<li>In a <em>derivation tree</em> or <em>parse tree</em>,<ul>
<li>the root is labeled $S$</li>
<li>internal nodes are labeled with a variable occurring on the left side of a production</li>
<li>the children of a node contain the symbols on the corresponding right side of a production</li>
</ul>
</li>
<li>In a full derivation tree, the root node represents the start variable $S$.</li>
<li>Any interior node and its children represent a production $A\rightarrow x$ used in the derivation;<ul>
<li>the node represents $A$, and the children, from left to right, represent the symbols in $x$.</li>
</ul>
</li>
<li>Each leaf node represents a symbol or $\lambda$.</li>
<li>The string derived is read off from left to right, ignoring $\lambda’$s.<ul>
<li>The <em><strong>yield</strong></em> of a derivation tree is the string of terminals produced by a leftmost depth-first traversal of the tree.</li>
</ul>
</li>
</ul>
<h5 id="5-4-Sentential-Forms-and-Derivation-Trees"><a href="#5-4-Sentential-Forms-and-Derivation-Trees" class="headerlink" title="5.4 Sentential Forms and Derivation Trees"></a>5.4 Sentential Forms and Derivation Trees</h5><ul>
<li><strong>Theorem 5.1</strong> states that:<ul>
<li>Given a context-free grammar $G$, for every string $w\in L(G)$, there exists a derivation tree whose yield is $w$.</li>
<li>The converse is also true: the yield of any derivation tree formed with productions from $G$ is in $L(G)$</li>
<li><strong>Note:</strong> Derivation trees show which productions are used in obtaining a sentence, but <em>do not give the order of their application</em>.</li>
</ul>
</li>
</ul>
<h5 id="5-5-Parsing-and-Membership"><a href="#5-5-Parsing-and-Membership" class="headerlink" title="5.5 Parsing and Membership"></a>5.5 Parsing and Membership</h5><ul>
<li><strong>The <em>parsing</em> problem</strong>: given a grammar $G$ and a string $w$, find a sequence of derivations using the productions in $G$ to produce $w$</li>
<li>To ensure that the problem may ne solved (regardless of efficiency) we need to require grammars to be given in a suitable shape</li>
<li>Exhausive parsing is guaranteed to yield all strings eventually, but many fail to stop for strings not in $L(G)$, unless we restrict the productions in the grammar.</li>
<li>Questions about the strings generated by a CFg are sometimes easier to answer if the productions have a retricted form:<ul>
<li>For example, if we know that a grammar has:<ul>
<li>no $\lambda$-productions ($A\rightarrow \lambda$),</li>
<li>and no unit productions ($A\rightarrow B$),</li>
</ul>
</li>
<li>we can deduce that no derivation of a string $x$ can take more than $2\vert x\vert - 1$.</li>
<li>We could then, in principle, determine whether $x$ can be derived by considering derivations no longer than $2\vert x\vert - 1$.</li>
</ul>
</li>
<li>There exists an algorithm which, for every CFG $G = (V, \Sigma, S, P)$, produces a CFG $G_1 = (V, \Sigma, S, P_1)$ which has no $\lambda$-productions, no unit productions of the form $A\rightarrow B$, and for which:<ul>
<li>$L(G_1) = L(G)-{\lambda}$</li>
</ul>
</li>
<li>With this conversion, the parsing problem may be solved in an exhaustive, top-down, but not very efficient fashion:</li>
<li><strong><u>Theorem 5.2</u></strong>: Exhaustive parsing is guaranteed to yield all strings eventually, but may fail to stop for strings not in $L(G)$, <em>unless if the grammar has no $\lambda$-productions or unit productions</em>.</li>
</ul>
<h5 id="5-6-Parsing-and-Ambiguity"><a href="#5-6-Parsing-and-Ambiguity" class="headerlink" title="5.6 Parsing and Ambiguity"></a>5.6 Parsing and Ambiguity</h5><ul>
<li>If $G$ is a CFG, then for any $x\in L(G)$ these three statements are equivalent:<ul>
<li>$x$ has more than one derivation tree.</li>
<li>$x$ has more than one LMD.</li>
<li>$x$ has more than one RMD.</li>
</ul>
</li>
<li>Thus, a CFG $G$ is <em><strong>ambiguous</strong></em> if and only if, for at least one $x\in L(G)$, $x$ has more than one LMD (or RMD).</li>
</ul>
<h5 id="5-7-Derivation-Trees-and-Ambiguity"><a href="#5-7-Derivation-Trees-and-Ambiguity" class="headerlink" title="5.7 Derivation Trees and Ambiguity"></a>5.7 Derivation Trees and Ambiguity</h5><ul>
<li><p>A classic example of ambiguity is <strong>the dangling <em>else</em></strong>.</p>
</li>
<li><p>In C, an if-statement can be defined by:</p>
<ul>
<li>$S\rightarrow if\ (E)\ S\ \mid\ if\ (E)\ S\ else\ S\ \mid\ OS$  (Where $OS$ stands for “other statement”).</li>
</ul>
</li>
<li><p>Consider the statement</p>
<p>$if\ (e1)\ if\ (e2)\ f();\ else\ g();$</p>
<ul>
<li>In C, the <em>else</em> should belong to the second $if$, but this grammar does not rule out interpreting the statement with $else$ belonging to the first $if$.</li>
</ul>
</li>
<li><p>Clearly the grammar given is ambiguous, <em>but there are equivalent grammars that allow only the correct interpretation</em>. For example:</p>
<p>$S\rightarrow S_1\ \mid\ S_2$</p>
<p>$S_1\rightarrow \ if\ (E)\ S_1\ else\ S_1\ \mid\ OS$</p>
<p>$S_2\rightarrow\ if\ (E)\ S\ \mid\ if\ (E)\ S_1\ else\ S_2$</p>
</li>
<li><p>These rules generate the same strings as the original ones and are unambiguous.</p>
</li>
</ul>
<h5 id="5-8-Ambiguous-Languages"><a href="#5-8-Ambiguous-Languages" class="headerlink" title="5.8 Ambiguous Languages"></a>5.8 Ambiguous Languages</h5><ul>
<li>For some languages, it is always possible to find an unambiguous grammar.</li>
<li>However, there are <em><strong>inherently ambiguous</strong></em> languages, for which every possible grammar is ambiguous.</li>
</ul>
<h5 id="5-9-Pumping-lemma-for-CFGs"><a href="#5-9-Pumping-lemma-for-CFGs" class="headerlink" title="5.9 Pumping lemma for CFGs"></a>5.9 Pumping lemma for CFGs</h5><ul>
<li>For every CFL $L$ there exists a natural number $n$ such that for any string $u\in L$ with $|u|\ge n$, there are $v, w, x, y, z$ such that $u = vwxyz$ and:<ol>
<li>$|wxy|\le n$</li>
<li>$|wy|\gt 0$</li>
<li>$\forall i\in N : vw^ixy^iz\in L$</li>
</ol>
</li>
</ul>
<h4 id="6-Pushdown-Automata"><a href="#6-Pushdown-Automata" class="headerlink" title="6. Pushdown Automata"></a>6. Pushdown Automata</h4><h5 id="6-1-Introduction"><a href="#6-1-Introduction" class="headerlink" title="6.1 Introduction"></a>6.1 Introduction</h5><ul>
<li><p>CFLs do not have anything similar to regular expressions.</p>
</li>
<li><p>But they do have a machine model, i.e., pushdown automata.</p>
</li>
<li><p>A pushdown automaton is essentially a finite automaton with a <em><strong>stack</strong></em> added as storage.</p>
</li>
<li><p>As there is no limit on the size of the stack, pushdown automata do not have bounded memory limitation of finite automata.</p>
</li>
<li><p>Pushdown automata are equivalent to CFGs, as long as we allow them to be nondeterministic.</p>
</li>
<li><p>The language family associated with deterministic pushdown automata is a proper subset of the context-free languages.</p>
</li>
<li><p>There are CFLs (such as $A^nB^n$) that cannot be recognized by finite automata</p>
</li>
<li><p>This is because the memory of a finite automata is restricted to a finite set of states, whereas the recognition of a CFL may require storing an unbounded amount of information.</p>
</li>
<li><p>Consider the following languages:</p>
<ul>
<li>$A^nB^m = {a^nb^m\mid n, m \ge 0}$, which is regular;</li>
<li>$A^nB^n = {a^nb^n\mid n\ge 0}$, which is not regular.</li>
</ul>
</li>
<li><p>To recognize strings in $A^nB^m$, all we need to do is to check that $a$’s appear before $b$’s, a task which can be done by a DFA.</p>
</li>
<li><p>In constrast, for $A^nB^n$, we must not only check that all $a$’s precede the first $b$, we must also <em><strong>count</strong></em> the number of $a$’s.</p>
</li>
<li><p>Since $n$ is unbounded, this counting cannot be done with a finite memory.</p>
</li>
<li><p>As the example of $A^nB^n$ shows, for the machine model of CFLs, we need a machine that can <em><strong>count without limit</strong></em>.</p>
</li>
<li><p>But, that is not enough. For instance, consider $WW^R = {ww^R\mid w\in {a, b}^*$, which is a CFL.</p>
</li>
<li><p>$WW^R$ shows that we need more than unlimited counting ability:</p>
<ul>
<li>We need the ability to store and match a sequence of symbols in <em><strong>reverse</strong></em> order.</li>
</ul>
</li>
<li><p>This suggests that we might try a <em><strong>stack</strong></em> as a storage mechanism, allowing unbounded storage that is restricted to operating like a stack.</p>
</li>
<li><p>This gives us a class of machines called pushdown automata (PDA), which we use as a model of computation to process context-free languages.</p>
</li>
</ul>
<h5 id="6-2-Nondeterministic-Pushdown-Automata"><a href="#6-2-Nondeterministic-Pushdown-Automata" class="headerlink" title="6.2 Nondeterministic Pushdown Automata"></a>6.2 Nondeterministic Pushdown Automata</h5><ul>
<li><p>Each move of the control unit:</p>
<ul>
<li>reads a symbol from the input file;</li>
<li>changes the contents of the stack (<em>through the usual stack operations</em>).</li>
</ul>
</li>
<li><p>Each move of the control unit is determined by:</p>
<ul>
<li>the current input symbol</li>
<li>and the symbol currently on top of the stack.</li>
</ul>
</li>
<li><p>The result of the move is a new state of the control unit and a change in the top of the stack.</p>
</li>
<li><p>A <em>nondeterministic pushdown accepter</em> (NPDA) $M = (Q, \Sigma, \Gamma, \delta, q_0, z, F)$ is defined by:</p>
<ul>
<li><p>$Q$: the finite set of internal states of the control unit</p>
</li>
<li><p>$\Sigma$: the finite set of input alphabet</p>
</li>
<li><p>$\Gamma$: the finite set of stack alphabet</p>
</li>
<li><p>$\delta$: the transition function with the type signature:<br>$$<br>\delta: Q\times (\Sigma \cup {\lambda})\times \Gamma\rightarrow P_f(Q\times \Gamma^*)<br>$$<br>$P_f(Q\times \Gamma^*)$ is the set of <em>finite</em> subsets of $(Q\times \Gamma^*)$</p>
</li>
<li><p>$q_0\in Q$: the initial state of the control unit</p>
</li>
<li><p>$z\in \Gamma$: the stack start symbol</p>
</li>
<li><p>$F\subseteq Q$: the set of final states</p>
</li>
<li><p>The arguments of $\delta$ are:</p>
<ul>
<li>the current state of the control unit</li>
<li>the current input symbol</li>
<li>and the current symbol on <em>top</em> of the stack</li>
</ul>
</li>
<li><p>The result is a finite set of pairs $(q, x)$, where:</p>
<ul>
<li>$q$ is the next state of the control unit</li>
<li>and $x$ is a <em><strong>string</strong></em> that is put on top of the stack <em><strong>in place of the single symbol</strong></em> there before.</li>
</ul>
</li>
<li><p>$\lambda$-transition: When the second argument of $\delta$ is $\lambda$, i.e., a move that does not consume an input symbol.</p>
</li>
<li><p>$\delta$ Always needs a stack symbol; i.e., no move is possible if the stack is empty.</p>
</li>
<li><p>Finally, the requirement that the elements of the range of $\delta$ be a <em><strong>finite</strong></em> subset is necessary because:</p>
<ul>
<li>$Q\times \Gamma^*$ is an infinite set and therefore has infinite subsets.</li>
<li>While an NPDA may have several choices for its moves, <em>this choice must be restricted to a finite set of possibilities</em>.</li>
</ul>
</li>
<li><p><strong>Note</strong>: If a particular transition is not defined, the corresponding (state, symbol, stack top) configuration represents a <em>dead</em> state.</p>
</li>
</ul>
</li>
<li><p>Transition Graphs</p>
<ul>
<li>Label the edges of the graph with three things:<ul>
<li>the current input symbol</li>
<li>the symbol at the top of the stack</li>
<li>and the string that replaces the top of the stack</li>
</ul>
</li>
</ul>
</li>
<li><p>Instantaneous Descriptions</p>
<ul>
<li><p>While transition graphs are convenient for <em>describing</em> NPDAs, they are not so suitable for formal reasoning.</p>
</li>
<li><p>To trace the operation of an NPDA, we must keep track of:</p>
<ul>
<li>the current state of the control unit,</li>
<li>the unread part of the input string,</li>
<li>and the stack contents.</li>
</ul>
</li>
<li><p><strong><u>Instantaneous Description</u></strong>: The triplet $(q, w, u)$ in which:</p>
<ul>
<li>$q$ is the state of the control unit,</li>
<li>$w$ is the unread part of the input string,</li>
<li>and $u$ is the stack contents:<ul>
<li>with the leftmost symbol indicating the top of the stack</li>
</ul>
</li>
</ul>
<p>is called an instantaneous description of a pushdown automaton.</p>
</li>
<li><p>A move from one instantaneous description to another will be denoted by the symbol $\vdash$</p>
</li>
<li><p>Thus $(q_1, aw, bx)\vdash (q_2, w, yx)$ is possible if and only if:<br>$$<br>(q_2, y)\in \delta (q_1, a, b)<br>$$</p>
</li>
<li><p>Moves involving an arbitrary number of steps will be denoted by $\vdash^*$.</p>
</li>
</ul>
</li>
</ul>
<h5 id="6-3-The-Language-Accepted-by-an-NPDA"><a href="#6-3-The-Language-Accepted-by-an-NPDA" class="headerlink" title="6.3 The Language Accepted by an NPDA"></a>6.3 The Language Accepted by an NPDA</h5><ul>
<li><p>The language accepted by an NPDA is the set of all strings that cause the NPDA to halt in a final state, after starting in $q_0$ with only the stack symbol $z$ on the stack.</p>
</li>
<li><p><em>The final contents of the stack are irrelevant</em>.</p>
</li>
<li><p>As was the case with nondeterministic finite automata, the string is accepted if <em>at least one</em> of the computations cause the NPDA to halt in a final state.</p>
</li>
<li><p>In other words, it does not require all the possible traces to end up in a final state.</p>
</li>
<li><p><strong><u>Definition 7.2</u></strong>: Let $M = (Q, \Sigma, \Gamma, \delta, q_0, z, F)$ be an NPDA. The language accepted by $M$ is the set:<br>$$<br>L(M) = {w\in \Sigma^<em>\mid (q_0, w, z) \vdash^</em> (p, \lambda, u), p\in F, u \in \Gamma^*}<br>$$</p>
</li>
</ul>
<h5 id="6-4-NPDAs-and-CFLs"><a href="#6-4-NPDAs-and-CFLs" class="headerlink" title="6.4 NPDAs and CFLs"></a>6.4 NPDAs and CFLs</h5><ul>
<li><p>A context-free grammar is in <em>Greibach Normal Form</em> if, in all of its productions, the right side consists of a single terminal follows by any number of variables</p>
</li>
<li><p><strong><u>Definition 6.5</u></strong>: A context-free grammar $G = (V, T, S, P)$ is said to be in <em><strong>Greibach normal form</strong></em> if all productions have the form<br>$$<br>A\rightarrow ax<br>$$<br>where $a\in T$ and $x\in V^*$.</p>
</li>
<li><p><strong><u>Theorem 6.7</u></strong>: For every context-free grammar $G$ there exists a grammar $\hat{G}$ in Greibach normal form satisfying:<br>$$<br>L(\hat{G}) = L(G) - {\lambda}<br>$$</p>
</li>
</ul>
<h5 id="6-5-NPDAs-for-CFLs"><a href="#6-5-NPDAs-for-CFLs" class="headerlink" title="6.5 NPDAs for CFLs"></a>6.5 NPDAs for CFLs</h5><ul>
<li><p><strong><u>Theorem 7.1</u></strong> For any given $\lambda$-free context-free language $L$, there exists an NPDA $M$ such that<br>$$<br>L(M) = L<br>$$</p>
</li>
<li><p>The constructive proof of Theorem 7.1 provides an algorithm that can be used to build the corresponding NPDA, for any language specified by a grammar $G$ in Greibach normal form.</p>
</li>
<li><p>The resulting NPDA simulates grammar derivations by:</p>
<ul>
<li>keeping variables on the stack</li>
<li>while making sure that the input symbol matches the terminal on the right side of the production.</li>
</ul>
</li>
</ul>
<h5 id="6-6-Construction-of-an-NPDA-from-a-Grammar-in-Greibach-Normal-Form"><a href="#6-6-Construction-of-an-NPDA-from-a-Grammar-in-Greibach-Normal-Form" class="headerlink" title="6.6 Construction of an NPDA from a Grammar in Greibach Normal Form"></a>6.6 Construction of an NPDA from a Grammar in Greibach Normal Form</h5><ul>
<li>The NPDA $M = ({q_0, q_1, q_f}, T, V\cup{z}, \delta, q_0,z {q_f})$ has:<ul>
<li>three states $Q = {q_0, q_1, q_f}$, with $q_0$ as the initial state, and $q_f$ as the only final state</li>
<li>input alphabet equal to the grammar terminal symbols $T$,</li>
<li>and stack alphabet equal to the grammar variable $V$, plus $z$, with the assumption that $z\notin V$</li>
</ul>
</li>
<li>The transition function contains the following:<ul>
<li>A rule that pushes $S$ on the stack and switches control to $q_1$ without consuming input:<ul>
<li>$\delta (q_0, \lambda, z) = {(q_1, Sz)}$</li>
</ul>
</li>
<li>For every production of the form $A\rightarrow au$, we have<ul>
<li>$(q_1, u)\in \delta (q_1, a, A)$</li>
</ul>
</li>
<li>A rule that switches the control unit to the final state $q_f$ when there is no more input, and the stack is empty:<ul>
<li>$\delta(q_1, \lambda, z) = {(q_f, z)}$</li>
</ul>
</li>
<li>If $\lambda \in L$, we add the transition $\delta(q_0, \lambda, z) = {(q_f, z)}$</li>
</ul>
</li>
</ul>
<h5 id="6-7-CFGs-for-PDAs"><a href="#6-7-CFGs-for-PDAs" class="headerlink" title="6.7 CFGs for PDAs"></a>6.7 CFGs for PDAs</h5><ul>
<li><strong><u>Theorem 7.2</u></strong>: If $L = L(M)$ for some NPDA $M$, then there exists a context-free grammar $G$ such that $L(G) = L(M)$. In other words, $L$ is a context-free language.</li>
<li>Proof: The basic idea behind the proof is to reverse the process in the proof of Theorem 7.1</li>
<li>The aim is to construct a grammar that simulates the moves of the NPDA $M$.</li>
<li>In particular:<ul>
<li>the content of the stack should be reflected in the variable part of sentential forms in derivations,</li>
<li>while the processed input is the terminal prefix of the sentential forms.</li>
</ul>
</li>
<li>Theorem 7.1 and 7.2 show that the following are equivalent, in the sense that they generate the same class of languages, i.e., context-free languages:<ul>
<li>Context-free grammars</li>
<li>NPDAs</li>
</ul>
</li>
<li>Which specification one chooses depends on the purpose:<ul>
<li>For specifying programming language constructs, grammars are more appropriate, as they are easier to understand by human beings.</li>
<li>For conputational purposes (e.g., compilation of a program) the machine model, i.e., NPDA, is more appropriate.</li>
</ul>
</li>
</ul>
<h5 id="6-8-Deterministic-Pushdown-Automata-DPDA"><a href="#6-8-Deterministic-Pushdown-Automata-DPDA" class="headerlink" title="6.8 Deterministic Pushdown Automata (DPDA)"></a>6.8 Deterministic Pushdown Automata (DPDA)</h5><p>A <em>deterministic pushdown accepter</em> (DPDA) never has more than one choice in its moves.</p>
<ul>
<li>For every $q\in Q, a\in \Sigma \cup {\lambda}$ and $b\in \Gamma$:<ul>
<li>$\delta (q, a, b)$ contains at most one element;</li>
<li>If $\delta(q, \lambda, b)$ is not empty, then $\delta(q, c, b)$ must be empty for every input symbol $c\in \Sigma$.<ul>
<li>when a $\lambda$-move is possible for some configuration, no input-consuming alternative is available.</li>
</ul>
</li>
</ul>
</li>
<li>Unlike the case for finite automata, a $\lambda$-transition does not necessarily mean the automaton is nondeterministic:<ul>
<li>Since the top of the stack plays a role in determining the next move, the presence of $\lambda$-transitions does not automatically imply nondeterminism.</li>
</ul>
</li>
<li>Also, some transitions of a DPDA may be to the empty set, that is, undefined, so there may be dead configurations.</li>
<li>This does not affect the definition either:<ul>
<li>The only criterion for determinism is that, at all times, <em>at most</em> one possible move exists.</li>
</ul>
</li>
</ul>
<h5 id="6-9-Deterministic-Context-Free-Languages-DCFLs"><a href="#6-9-Deterministic-Context-Free-Languages-DCFLs" class="headerlink" title="6.9 Deterministic Context-Free Languages (DCFLs)"></a>6.9 Deterministic Context-Free Languages (DCFLs)</h5><ul>
<li><p>A context-free language $L$ is <em>deterministic</em> if there is a DPDA $M$ such that:<br>$$<br>L = L(M)<br>$$</p>
</li>
<li><p>There are, however, languages which are context-free, but not DCFL.</p>
<ul>
<li>This shows that, <em><strong>deterministic and nondeterministic pushdown automata are not equivalent.</strong></em></li>
</ul>
</li>
</ul>
<h5 id="6-10-Importance-of-DCFLs"><a href="#6-10-Importance-of-DCFLs" class="headerlink" title="6.10 Importance of DCFLs"></a>6.10 Importance of DCFLs</h5><ul>
<li>The importance of deterministic context-free languages lies in the fact that they can be <em><strong>parsed efficiently</strong></em>.</li>
<li>Think of the pushdown automaton as a parsing device:<ul>
<li>Since there is no backtracking involved, we can easily write a computer program for it, and we may expect that it will work efficiently.</li>
<li>Since there may be $\lambda$-transitions involved, we cannot immediately claim that this will yield a linear-time parser, but it puts us on the right track, nevertheless.</li>
</ul>
</li>
</ul>
<h4 id="7-Turing-Machines"><a href="#7-Turing-Machines" class="headerlink" title="7. Turing Machines"></a>7. Turing Machines</h4><h5 id="7-1-The-Standard-Turing-Machine"><a href="#7-1-The-Standard-Turing-Machine" class="headerlink" title="7.1 The Standard Turing Machine"></a>7.1 The Standard Turing Machine</h5><ul>
<li>A standard Turing machine has unlimited storage in the form of a tape:<ul>
<li>The tape consists of an infinite number of cells,</li>
<li>with each cell capable of storing one symbol.</li>
</ul>
</li>
<li>The read-write head can travel in <em><strong>both</strong></em> directions on the tape, processing one symbol per move.</li>
<li>In a standard Turing machine, the tape acts as the:<ul>
<li>input,</li>
<li>output,</li>
<li>and storage medium.</li>
</ul>
</li>
<li>A control function causes the machine to change states and possibly overwrite the tape contents:<ul>
<li>Deterministic and non-deterministic Turing machines turn out to be as powerful as each other.</li>
</ul>
</li>
<li>The input string is surrounded by blanks, so the input alphabet is considered a proper subset of the tape alphabet.</li>
</ul>
<h5 id="7-2-Definition-of-a-Turing-Machine"><a href="#7-2-Definition-of-a-Turing-Machine" class="headerlink" title="7.2 Definition of a Turing Machine"></a>7.2 Definition of a Turing Machine</h5><ul>
<li><strong><u>Definition 9.1</u></strong>: A <em>Turing Machine</em> $M = (Q, \Sigma, \Gamma, \delta, q_0, \Box, F)$ is defined by:<ul>
<li>$Q$: a finite set of internal states</li>
<li>$\Sigma$: the input alphabet</li>
<li>$\Gamma$: the tape alphabet</li>
<li>$\delta$: $Q\times \Gamma\rightarrow Q\times \Gamma \times {L, R}$: the transition function</li>
<li>$\Box \in \Gamma$: a special symbol called the blank</li>
<li>$q_0 \in Q$: the initial state</li>
<li>$F \subseteq Q$: the set of final states</li>
</ul>
</li>
<li>In the definition of a Turing machine, we assume that: $\Sigma \subseteq \Gamma - {\Box}$.</li>
<li>In other words, the input alphabet is a subset of the tape alphabet, and the blank symbol is not in the input alphabet.</li>
<li>Transition Function $\delta$<ul>
<li>$\delta: Q\times \Gamma \rightarrow Q \times \Gamma \times {L, R}$</li>
<li>Input to the transition function $\delta$ consists of:<ul>
<li>the current state of the control unit</li>
<li>and the current tape symbol</li>
</ul>
</li>
<li>Output of $\delta$ consists of:<ul>
<li>a new state,</li>
<li>a new tape symbol,</li>
<li>and location of the next symbol to be read (left or right)</li>
</ul>
</li>
<li>In general, $\delta$ is a partial function, so that some (state, symbol) input combinations may be undefined.</li>
</ul>
</li>
</ul>
<h5 id="7-3-Transition-Graphs-for-Turing-Machines"><a href="#7-3-Transition-Graphs-for-Turing-Machines" class="headerlink" title="7.3 Transition Graphs for Turing Machines"></a>7.3 Transition Graphs for Turing Machines</h5><ul>
<li>Label the edges of the graph with three items:<ul>
<li>the current tape symbol,</li>
<li>the symbol that replaces it,</li>
<li>and the direction in which the read-write head is to move.</li>
</ul>
</li>
</ul>
<h5 id="7-4-A-Turing-machine-that-Never-Halts"><a href="#7-4-A-Turing-machine-that-Never-Halts" class="headerlink" title="7.4 A Turing machine that Never Halts"></a>7.4 A Turing machine that Never Halts</h5><ul>
<li>It is possible for a Turing machine to never halt on certain inputs.</li>
<li>The machine runs forever with the read-write head moving alternately right and left but making no modifications to the tape.</li>
<li>In fact, it should be clear that this particular machine will run forever, <em>regardless of the initial information on its tape</em>, with the read-write head moving alternately right then left but making no modifications to the tape.</li>
<li>In the analogy with programming terminology, we say that the Turing machine is in an <em><strong>infinite loop</strong></em>.</li>
</ul>
<h5 id="7-5-Instantaneous-Description"><a href="#7-5-Instantaneous-Description" class="headerlink" title="7.5 Instantaneous Description"></a>7.5 Instantaneous Description</h5><ul>
<li><p>The most convenient way to exhibit a sequence of configurations of a Turing machine uses the idea of an <em>instantaneous description</em>.</p>
</li>
<li><p>Any configuration is completely determined by:</p>
<ul>
<li>the current state of the control unit,</li>
<li>the contents of the tape,</li>
<li>and the position of the read-write head.</li>
</ul>
</li>
<li><p>Use the notation in which $x_1qx_2$ or $a_1a_2\cdots a_{k-1}qa_ka_{k+1}\cdots a_n$ is the instantaneous description of a machine in state $q$ with the tape depicted in the figure below.</p>
<img src="/2021/05/15/Formal-Languages/Screen Shot 2021-05-06 at 5.25.49 PM.png" style="zoom:50%;"></li>
<li><p>This convention is chosen so that the position of the read-write head is over the cell containing the symbol immediately following $q$.</p>
</li>
<li><p>The instantaneous description gives only a finite amount of information to the right and left of the read-write head.</p>
</li>
<li><p>The unspecified part of the tape is assumed to contain all blanks.</p>
</li>
<li><p>Normally, such blanks are irrelevant and are not shown explicitly in the instantaneous description.</p>
</li>
<li><p>If the position of blanks is relevant to the discussion, however, the blank symbol may appear in the instantaneous description.</p>
</li>
</ul>
<h5 id="7-6-The-Language-Accepted-by-a-Turing-Machine"><a href="#7-6-The-Language-Accepted-by-a-Turing-Machine" class="headerlink" title="7.6 The Language Accepted by a Turing Machine"></a>7.6 The Language Accepted by a Turing Machine</h5><ul>
<li><p><strong><u>Definition 9.3</u></strong>: Let $M = (Q, \Sigma, \Gamma, \delta, q_0, \Box, F)$ be a Turing machine. Then the language accepted by $M$ is:<br>$$<br>L(M) = {w\in \Sigma^+\mid q_0w\vdash^* x_1q_fx_2,\ for\ some\ q_f\in F, x_1, x_2\in \Gamma^*}<br>$$</p>
</li>
<li><p>The language accepted by a Turing machine is the set of all strings which cause the machine to halt in a final state, when started in its standard initial configuration.</p>
</li>
<li><p>A string is rejected if</p>
<ul>
<li>The machine halts in a nonfinal state, or</li>
<li><em><strong>The machine never halts</strong></em></li>
</ul>
</li>
<li><p>$M$ is said to halt starting from some initial configuration $x_1q_ix_2$ if<br>$$<br>x_1q_ix_2\vdash^* y_1q_jay_2<br>$$<br>for any $q_j$ and $a$, for which $\delta(q_j, a)$ is undefined.</p>
</li>
<li><p>Turing machines are more powerful than the previous classes of automata that we have studied (i.e., FAs, and PDAs).</p>
</li>
</ul>
<h5 id="7-7-Turing-Machines-as-Transducers"><a href="#7-7-Turing-Machines-as-Transducers" class="headerlink" title="7.7 Turing Machines as Transducers"></a>7.7 Turing Machines as Transducers</h5><ul>
<li><p>Turing machines provide an abstract model for digital computers, acting as a transducer that transforms input into output.</p>
</li>
<li><p>A <em>Turing machine transducer</em> implements a function that treats the original contents of the tape as its input and the final contents of the tape as its output.</p>
</li>
<li><p>A function is <em>Turing-computable</em> if it can be carried out by a Turing machine capable of processing all values in the function domain.</p>
</li>
<li><p><strong><u>Definition 9.4</u></strong>: A function $f$ with domain $D$ is said to be Turing-computable if there exists some Turing machine $M = (Q, \Sigma, \Gamma, \delta, q_0, \Box, F)$ such that, for all $w \in D$:<br>$$<br>q_0w\vdash^*q_ff(w)<br>$$<br>for some final state $q_f\in F$, <em><strong>and for any input $w\notin D$, the machine $M$ does not halt in a final state.</strong></em></p>
</li>
<li><p>Turing machines are the most powerful model of computation as transducers as well.</p>
</li>
<li><p>In fact, all the common mathematical functions are Turing-computable, e.g.:</p>
<ul>
<li>Arithmetic operators, Exponentiation, Integer logarithm;</li>
<li>Comparison;</li>
<li>String manipulation;</li>
<li>Etc.</li>
</ul>
</li>
</ul>
<h5 id="7-8-Combining-Turing-Machines"><a href="#7-8-Combining-Turing-Machines" class="headerlink" title="7.8 Combining Turing Machines"></a>7.8 Combining Turing Machines</h5><ul>
<li>By combining Turing Machines that perform simple tasks, complex algorithms can be implemented.</li>
</ul>
<h5 id="7-9-Universal-Turing-Machines"><a href="#7-9-Universal-Turing-Machines" class="headerlink" title="7.9 Universal Turing Machines"></a>7.9 Universal Turing Machines</h5><ul>
<li>The TMs we have studied so far have been special-purpose computers capable of executing a single algorithm.</li>
<li>We can consider a “universal” Turing machine, which can execute a program stored in its memory:<ul>
<li>It receives an input string that specifies both:<ul>
<li>the algorithm it is to execute</li>
<li>and the input that is to be provided to the algorithm</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="7-10-The-Church-Turing-Thesis"><a href="#7-10-The-Church-Turing-Thesis" class="headerlink" title="7.10 The Church-Turing Thesis"></a>7.10 The Church-Turing Thesis</h5><ul>
<li>To say that the TM is a general model of computation implies that:<ul>
<li><em>“any algorithmic procedure that can be carried out at all, by a human computer or a team of humans or an electronic computer, can be carried out by a TM”</em>.</li>
</ul>
</li>
<li>An acceptance of the Church-Turing Thesis leads to a <em><strong>definition of an algorithm</strong></em>:<ul>
<li>An <em>algorithm</em> for a function $f: D\rightarrow R$ is a Turing machine $M$, which given any $d\in D$ on its tape, eventually halts with the correct answer $f(d)\in R$ on its tape.</li>
</ul>
</li>
<li>The nature of the model makes it seems that a TM can execute any algorithm a human can.</li>
<li>Apparent enhancements to the TM have been shown not to increase its power.</li>
<li>Other models of computation proposed have either been less powerful or equivalent to Turing machines.</li>
<li>No one has ever suggested any kind of <em><strong>effective</strong></em> computation that cannot be implemented on a TM</li>
<li>From now on, we will consider that, by definition, <em><strong>an “algorithmic procedure” is what a Turing machine can do</strong></em>.</li>
</ul>
<h5 id="7-11-The-Chomsky-Hierarchy"><a href="#7-11-The-Chomsky-Hierarchy" class="headerlink" title="7.11 The Chomsky Hierarchy"></a>7.11 The Chomsky Hierarchy</h5><ul>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-05-14 at 12.41.00 PM.png" style="zoom:50%;"></li>
<li><img src="/2021/05/15/Formal-Languages/Screen Shot 2021-05-14 at 12.41.10 PM.png" style="zoom:50%;"></li>
</ul>
<h4 id="8-Easy-wrong-topic"><a href="#8-Easy-wrong-topic" class="headerlink" title="8. Easy wrong topic"></a>8. Easy wrong topic</h4><ul>
<li><p>Is every formal language regular? No. $L = {a^nb^n : n \ge 0}$ is not regular.</p>
</li>
<li><p>$L = \emptyset$ is regular language.</p>
</li>
<li><p>$G = (V, T, S, P)$, $S \rightarrow aSb \mid S$, $L(G)$ is regular, because the production cannot halt, the language is empty.</p>
</li>
<li><p>Every finite language is regular. Therefore, every non-regular language is infinite.</p>
</li>
<li><p>Context Free contains regular languages, regular languages contain finite language</p>
</li>
</ul>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">CL Turbo</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://scycy2.github.io/2021/05/15/Formal-Languages/">https://scycy2.github.io/2021/05/15/Formal-Languages/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">CL Turbo</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Language-and-Computation/">
                                    <span class="chip bg-color">Language and Computation</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/05/26/Red-Black-Tree/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Red-Black Tree">
                        
                        <span class="card-title">Red-Black Tree</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Red Black Tree and Operations
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-05-26
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/class-notes/" class="post-category">
                                    class notes
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Data-Structure/">
                        <span class="chip bg-color">Data Structure</span>
                    </a>
                    
                    <a href="/tags/Algorithm/">
                        <span class="chip bg-color">Algorithm</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/04/15/Pattern-Matching/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="Pattern Matching">
                        
                        <span class="card-title">Pattern Matching</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Pattern Matching
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-04-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/class-notes/" class="post-category">
                                    class notes
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Algorithm/">
                        <span class="chip bg-color">Algorithm</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\(', '\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
    <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": { 
        preferredFont: "TeX", 
        availableFonts: ["STIX","TeX"], 
        linebreaks: { automatic:true }, 
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) 
    },
    tex2jax: { 
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ], 
        processEscapes: true, 
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {  
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, 
        Macros: { href: "{}" } 
    },
    messageStyle: "none"
    }); 
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
    
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        font-size: 15px;
        color: #42b983;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="7917344806"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='metadata'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="/about" target="_blank">CL Turbo</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">43.5k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "7";
                    var startDate = "17";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/scycy2" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:Chenglei.You@outlook.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=879314144" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 879314144" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    

</body>

</html>
